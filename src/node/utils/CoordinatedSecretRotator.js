'use strict';

const crypto = require('crypto');
const db = require('../db/DB');
const log4js = require('log4js');
const util = require('util');

const randomBytes = util.promisify(crypto.randomBytes);
const randomString = async (len) => (await randomBytes(len)).toString('hex');

class Secret {
  static fromJSON(j) { return new Secret(j.secret, j.start, j.end, j.lifetime); }
  constructor(secret, start, end, lifetime) { Object.assign(this, {secret, start, end, lifetime}); }
  equals(other) { return JSON.stringify(this) === JSON.stringify(other); }
  [util.inspect.custom](depth, options, inspect) {
    if (inspect == null) inspect = util.inspect;
    return inspect({
      secret: this.secret.length > 11 ? `${this.secret.slice(0, 8)}...` : this.secret,
      start: new Date(this.start).toJSON(),
      end: new Date(this.end).toJSON(),
      lifetime: this.lifetime,
    }, options);
  }
}

/**
 * Maintains an array of secrets across one or more Etherpad instances sharing the same database,
 * periodically rotating in a new secret and removing the oldest secret.
 *
 * The protocol assumes each instance's clock sync error is much less than the secret rotation
 * interval. Protocol overview:
 *   - Every `interval` milliseconds, each Etherpad instance generates and publishes (to a new
 *     location in the database) a new list of secrets.
 *   - Each published list is a union of all secrets previously published by all Etherpad instances,
 *     excluding obsolete secrets, plus a candidate for the next secret (explained below).
 *   - The list of secrets is published in the database at key
 *     `${dbPrefix}:${instanceId}:${serialNumber}` where:
 *       - instanceId: A globally unique identifier (no colons) for the Etherpad instance. This
 *         value is randomly generated by the CoordinatedSecretRotator constructor.
 *       - serialNumber: Starts at 0 and is incremented each time the Etherpad instance generates a
 *         new list of secrets.
 *   - The value written to the database is an array of objects, each with the following properties:
 *       - secret: The secret (a string).
 *       - start: When the secret became/becomes the secret used for generating new MACs
 *         (milliseconds since epoch).
 *       - end: When the secret stopped/stops being the secret used for generating new MACs
 *         (milliseconds since epoch).
 *       - lifetime: How long MACs created with this secret last before they expire. (This secret
 *         becomes obsolete at time end + lifetime, modulo clock sync error.)
 *   - To keep the list of secrets as small as possible, all Etherpad instances agree upon the same
 *     secret to use for the next interval. How it works: At the start of each interval, each
 *     Etherpad instance generates and publishes a candidate for the next interval. Before the start
 *     of the next interval, each Etherpad instance looks at all of the published candidates and
 *     picks the one published by the instance with the lowest ID.
 *   - The chosen candidate is included in the list of secrets in case clock sync error causes an
 *     instance to start using the chosen candidate before another instance starts the new interval.
 */
class CoordinatedSecretRotator {
  /**
   * @param {string} dbPrefix - Database key prefix to use for published secrets.
   * @param {number} interval - How often to switch to a new secret for generating MACs.
   * @param {number} lifetime - How long a MAC should be considered valid after it is created.
   * @param {string} [legacyStaticSecret] - Optional secret to facilitate migration to secret
   *     rotation. If the oldest known secret starts after `lifetime` ago, this secret will cover
   *     the time period starting `lifetime` ago and ending at the start of that secret.
   */
  constructor(dbPrefix, interval, lifetime, legacyStaticSecret = null) {
    this._dbPrefix = dbPrefix;
    this._interval = interval;
    this._lifetime = lifetime;
    this._legacyStaticSecret = legacyStaticSecret;
    this._id = null;
    this._nextSerial = 0;
    this._updateTimeout = null;
    this._publishedSecrets = null;
    this._logger = null;

    /**
     * The secrets. The first secret in this array is the one that should be used to generate new
     * MACs. All of the secrets in this array should be used to authenticate an existing MAC. The
     * contents of this array will be changed every `interval` milliseconds, but the Array object
     * itself will never be replaced with a new Array object.
     *
     * @type {string[]}
     * @public
     */
    this.secrets = [];
    Object.defineProperty(this, 'secrets', {writable: false}); // Defend against bugs.
  }

  async start() {
    this._id = await randomString(16);
    this._logger = log4js.getLogger(`secret-rotation (${this._dbPrefix}:${this._id})`);
    this._logger.debug(
        `starting secret rotation (interval ${this._interval}, lifetime ${this._lifetime})`);
    await this._chooseAndPublishSecrets();
    this._activatePublishedSecrets();
    const scheduleNext = () => {
      const now = Date.now();
      // Run twice each interval: At the start of each rotation interval and half way between. The
      // purpose of the run at the start of the interval is to activate the already chosen secrets
      // and to publish a candidate for the next interval. The half-way run selects which candidate
      // will be used for the next interval. The candidate selection is done half-way through to
      // accommodate some clock sync error between multiple Etherpad instances.
      const when = now - (now % (this._interval / 2)) + (this._interval / 2);
      this._updateTimeout = setTimeout(async () => {
        this._activatePublishedSecrets();
        await this._chooseAndPublishSecrets();
        scheduleNext();
      }, when - now);
    };
    scheduleNext();
  }

  async stop() {
    this._logger.debug(`stopping secret rotation for ${this._dbPrefix}`);
    clearTimeout(this._updateTimeout);
    this._updateTimeout = null;
  }

  async _newSecret(start) {
    return new Secret(await randomString(32), start, start + this._interval, this._lifetime);
  }

  async _chooseAndPublishSecrets() {
    // Determine what sets of secrets have already been published.
    const maxSerialNumbers = new Map();
    const keys = new Set(await db.findKeys(`${this._dbPrefix}:*`, null));
    await Promise.all([...keys].map(async (key) => {
      const [, id, sn] = key.split(':');
      const n = Number.parseInt(sn);
      const {n: maxN, key: maxKey} = maxSerialNumbers.get(id) || {};
      if (maxN == null || n > maxN) maxSerialNumbers.set(id, {n, key});
      if (maxN == null) return;
      keys.delete(maxN > n ? key : maxKey);
      await db.remove(maxN > n ? key : maxKey);
    }));

    // Read the existing secrets and determine which ones should be kept.
    const now = Date.now();
    const t0 = now - (now % this._interval); // The current rotation interval's start time.
    const t1 = t0 + this._interval; // End of the current rotation interval / start of the next.
    const t2 = t1 + this._interval; // End of the next rotation interval.
    let nowSecret = null;
    let needFuture = true;
    let legacyEnd = now;
    const futureCandidates = new Map();
    // Contains the secrets that are live right now. Each entry's key is a secret string, and the
    // corresponding value is an Array of Secret objects whose secrets match the key.
    const currentSecrets = new Map();
    const addSecret = (s) => {
      if (s.start < legacyEnd) legacyEnd = s.start;
      let secrets = currentSecrets.get(s.secret);
      if (secrets == null) {
        secrets = [];
        currentSecrets.set(s.secret, secrets);
      }
      // Filter out duplicates. Don't worry about combining intervals -- the same secret with
      // different start, end, or lifetime values shouldn't happen in practice. (And if it does,
      // the overhead is low and it'll eventually go away on its own.)
      for (const o of secrets) if (s.equals(o)) return;
      if (s.start <= t0 && s.end >= t1) {
        if (nowSecret != null && s.equals(nowSecret)) return;
        nowSecret = s;
        return;
      }
      secrets.push(s);
    };
    await Promise.all([...keys].map(async (key) => {
      // Filter out all expired secrets, with some margin (this._interval) in case multiple Etherpad
      // instances are sharing the same database and their clocks aren't perfectly in sync.
      const ss = (await db.get(key) || []).map((s) => Secret.fromJSON(s)).filter((s) => {
        if (s.start < legacyEnd) legacyEnd = s.start;
        return Date.now() < s.end + s.lifetime + this._interval;
      });
      if (ss.length === 0) await db.remove(key);
      for (const s of ss) {
        if (s.start < t1) {
          addSecret(s);
          if (s.end >= t2) needFuture = false;
        } else if (needFuture && s.start <= t1 && s.end >= t2) {
          const [, id] = key.split(':');
          futureCandidates.set(id, s);
        }
      }
    }));
    this._publishedSecrets = [...currentSecrets.values()].flat();

    // Add new and legacy secrets if needed.
    if (nowSecret == null) nowSecret = await this._newSecret(t0);
    this._publishedSecrets.unshift(nowSecret); // Always put the "now" secret at the beginning.
    const legacyStart = now - this._lifetime;
    if (this._legacyStaticSecret && legacyStart < legacyEnd) {
      this._logger.debug(
          `adding legacy static secret for period ${new Date(legacyStart).toJSON()} to ` +
          `${new Date(legacyEnd).toJSON()} with lifetime ${this._lifetime}`);
      this._publishedSecrets.push(
          new Secret(this._legacyStaticSecret, legacyStart, legacyEnd, this._lifetime));
    }
    if (needFuture) {
      if (futureCandidates.size === 0) futureCandidates.set(this._id, await this._newSecret(t1));
      const [winnerId] = [...futureCandidates.keys()].sort();
      this._publishedSecrets.push(futureCandidates.get(winnerId));
    }

    // Publish the secrets for other Etherpad instances to see.
    const oldSerial = this._nextSerial - 1;
    await db.set(`${this._dbPrefix}:${this._id}:${this._nextSerial++}`, this._publishedSecrets);
    // Wait for the new set of secrets to be written before deleting the old set to avoid any race
    // conditions.
    if (oldSerial >= 0) await db.remove(`${this._dbPrefix}:${this._id}:${oldSerial}`);
    this._logger.debug('published secrets:', this._publishedSecrets);
  }

  _activatePublishedSecrets() {
    this.secrets.length = 0;
    this.secrets.push(...this._publishedSecrets.map(({secret}) => secret));
    this._logger.debug('active secrets:', this.secrets);
  }
}

module.exports = CoordinatedSecretRotator;
